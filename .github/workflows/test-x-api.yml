name: Test X API Connection

on:
  workflow_dispatch: # 手動実行のみ

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Debug - Check secrets are set
        env:
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_SECRET: ${{ secrets.X_API_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
          X_ACCESS_TOKEN_SECRET: ${{ secrets.X_ACCESS_TOKEN_SECRET }}
        run: |
          echo "Checking if secrets are set..."
          if [ -z "$X_API_KEY" ]; then echo "X_API_KEY is EMPTY"; else echo "X_API_KEY is set (length: ${#X_API_KEY})"; fi
          if [ -z "$X_API_SECRET" ]; then echo "X_API_SECRET is EMPTY"; else echo "X_API_SECRET is set (length: ${#X_API_SECRET})"; fi
          if [ -z "$X_ACCESS_TOKEN" ]; then echo "X_ACCESS_TOKEN is EMPTY"; else echo "X_ACCESS_TOKEN is set (length: ${#X_ACCESS_TOKEN})"; fi
          if [ -z "$X_ACCESS_TOKEN_SECRET" ]; then echo "X_ACCESS_TOKEN_SECRET is EMPTY"; else echo "X_ACCESS_TOKEN_SECRET is set (length: ${#X_ACCESS_TOKEN_SECRET})"; fi

      - name: Test X API (Read only - no tweet posted)
        env:
          X_API_KEY: ${{ secrets.X_API_KEY }}
          X_API_SECRET: ${{ secrets.X_API_SECRET }}
          X_ACCESS_TOKEN: ${{ secrets.X_ACCESS_TOKEN }}
          X_ACCESS_TOKEN_SECRET: ${{ secrets.X_ACCESS_TOKEN_SECRET }}
        run: |
          node -e "
          const crypto = require('crypto');
          const https = require('https');

          const API_KEY = process.env.X_API_KEY;
          const API_SECRET = process.env.X_API_SECRET;
          const ACCESS_TOKEN = process.env.X_ACCESS_TOKEN;
          const ACCESS_TOKEN_SECRET = process.env.X_ACCESS_TOKEN_SECRET;

          function generateOAuthSignature(method, url, params, consumerSecret, tokenSecret) {
            const sortedParams = Object.keys(params)
              .sort()
              .map(key => encodeURIComponent(key) + '=' + encodeURIComponent(params[key]))
              .join('&');
            const signatureBase = [method.toUpperCase(), encodeURIComponent(url), encodeURIComponent(sortedParams)].join('&');
            const signingKey = encodeURIComponent(consumerSecret) + '&' + encodeURIComponent(tokenSecret);
            return crypto.createHmac('sha1', signingKey).update(signatureBase).digest('base64');
          }

          function generateOAuthHeader(method, url) {
            const oauthParams = {
              oauth_consumer_key: API_KEY,
              oauth_nonce: crypto.randomBytes(16).toString('hex'),
              oauth_signature_method: 'HMAC-SHA1',
              oauth_timestamp: Math.floor(Date.now() / 1000).toString(),
              oauth_token: ACCESS_TOKEN,
              oauth_version: '1.0'
            };
            oauthParams.oauth_signature = generateOAuthSignature(method, url, oauthParams, API_SECRET, ACCESS_TOKEN_SECRET);
            const headerParts = Object.keys(oauthParams).sort().map(key => encodeURIComponent(key) + '=\"' + encodeURIComponent(oauthParams[key]) + '\"').join(', ');
            return 'OAuth ' + headerParts;
          }

          const url = 'https://api.twitter.com/2/users/me';
          const options = {
            hostname: 'api.twitter.com',
            port: 443,
            path: '/2/users/me',
            method: 'GET',
            headers: { 'Authorization': generateOAuthHeader('GET', url) }
          };

          const req = https.request(options, (res) => {
            let body = '';
            res.on('data', (chunk) => body += chunk);
            res.on('end', () => {
              console.log('Status:', res.statusCode);
              console.log('Response:', body);
              if (res.statusCode === 200) {
                console.log('✅ READ ACCESS OK');
              } else {
                console.log('❌ READ ACCESS FAILED');
                process.exit(1);
              }
            });
          });
          req.on('error', (e) => { console.error('Error:', e); process.exit(1); });
          req.end();
          "
